#'**TIMETREE**
#'========================================================================================================
#'
#'=========================================================================================================
ancestral <- seqinr::read.alignment(file = (paste(args, "/Timetree/ancestral_sequences.fasta", sep = "")), format = "fasta")
ancestral$nam <- gsub("\\..*", "", ancestral$nam, perl = T)
#############################################
#           RUN DESIGNATION                #
#############################################
sequence_designation<-MADDOG::seq_designation(tree, 90, alignment, metadata, ancestral)
min.support<-90
tree$node.comment<- gsub(".*=", "", tree$node.label, perl = T)
alignment_matrix <- seqinr::as.matrix.alignment(alignment)
ancestral_matrix <- seqinr::as.matrix.alignment(ancestral)
sequences <- 10
max.support<-100
#############################################
#            BOOTSTRAP SUPPORT              #
#############################################
# Identify nodes with a bootstrap of over 70 (why would the first ~570 nodes be NA?)
nodes_70 <- which(tree$node.comment > min.support | tree$node.comment == max.support)
nodes_70 <- nodes_70 + length(tree$tip.label)
node_data <- data.frame(Node = nodes_70, n_tips = NA)
for(i in 1:length(nodes_70)) {
node_data[i,2] <- length(phangorn::Descendants(tree, nodes_70[i], type = "tips")[[1]])
}
nodes_5 <- node_data[(which(node_data[,2]>= sequences)),]
#############################################
#            95% COVERAGE WGS               #
#############################################
# Make a dataframe ready to fill with info about number of gaps and N bases, and length of the alignment and sequence
seq_data <- data.frame(ID = alignment$nam, N = NA, "gap" = NA,
Length_before = nchar(alignment$seq[[1]]), Length_after = NA)
for (i in 1:length(alignment$seq)) {
seq_data$N[i] <- stringr::str_count(alignment$seq[[i]], pattern = 'n')
seq_data$gap[i] <- stringr::str_count(alignment$seq[[i]], pattern = '-')
seq_data$Length_after[i] <- (seq_data$Length_before[i] - seq_data$N[i] - seq_data$gap[i])
}
nodes_remove <- phangorn::Ancestors(tree,
(which(tree$tip.label
%in% (seq_data$ID[which(seq_data$Length_after < (seq_data$Length_before * 0.95))])
)),
'all')
removes <- nodes_remove[[1]]
for (i in 2:(length(nodes_remove))) {
removes <- c(removes, nodes_remove[[i]])
}
remove_counts <- data.frame(table(removes))
names(remove_counts) <-c('Node', 'freq')
remove_counts$Node <- as.integer(levels(remove_counts$Node))
new_remove <- remove_counts[which(remove_counts[,1] %in% nodes_5[,1]),]; new_remove
nodes_new<-nodes_5
for (i in new_remove$Node) {
nodes_new[which(nodes_new == i), 2] <-(nodes_5[which(nodes_5 == i), 2] - (new_remove[which(new_remove == i), 2]))
}
nodes_5 <- nodes_new[(which(nodes_new[,2] >= sequences)),] # Redo this to remove any that now have less than 5, and write over the old nodes_5 so this is updated with the new tip numbers
rm(list=ls())
args=("Emilia")
tree <- ape::read.tree(file = paste(args, "/Trees/", args, "_aligned.fasta.contree", sep = ""))
# Sequence names got messed up in MAFFT, need to fix these so they match metadata and alignment
# Also node comment is sometimes weird, fix it
# #KB- can replace above 2 lines with this:
tree$tip.label <- gsub("\\..*", "", tree$tip.label, perl = T)
tree$node.comment<- gsub(".*=", "", tree$node.label, perl = T)
#'**METADATA**
#'========================================================================================================
#' The metadata must contain the element 'year' which lists the collection year for each sequence
#' And the element 'ID' which lists all the sequence ID's
#' These sequence ID's must match the sequence ID's in the tree and alignment
#'=========================================================================================================
metadata <- read.csv(file = paste(args, "/", args, "_metadata.csv", sep = ""))
#'**ALIGNMENT**
#'========================================================================================================
#' The alignment must contain the element 'seq' which contains the sequences
#' And the element 'nam' which lists all the sequence ID's
#' These sequence ID's must match the sequence ID's in the metadata and tree
#'=========================================================================================================
alignment <- seqinr::read.alignment(file = (paste(args, "/Alignment/", args, "_aligned.fasta", sep = "")), format = "fasta")
# Sequence names got messed up in MAFFT, need to fix these so they match metadata and alignment
# #KB- can replace above 2 lines with this:
alignment$nam <- gsub("\\..*", "", alignment$nam, perl = T)
#'**TIMETREE**
#'========================================================================================================
#'
#'=========================================================================================================
ancestral <- seqinr::read.alignment(file = (paste(args, "/Timetree/ancestral_sequences.fasta", sep = "")), format = "fasta")
ancestral$nam <- gsub("\\..*", "", ancestral$nam, perl = T)
min.support<-90
tree$node.comment<- gsub(".*=", "", tree$node.label, perl = T)
alignment_matrix <- seqinr::as.matrix.alignment(alignment)
ancestral_matrix <- seqinr::as.matrix.alignment(ancestral)
sequences <- 10
max.support<-100
nodes_70 <- which(tree$node.comment > min.support | tree$node.comment == max.support)
nodes_70 <- nodes_70 + length(tree$tip.label)
node_data <- data.frame(Node = nodes_70, n_tips = NA)
# Make a dataframe ready for values to be put in
# Fill the first column with the numbers of the nodes identified in the previous steps
for(i in 1:length(nodes_70)) {
node_data[i,2] <- length(phangorn::Descendants(tree, nodes_70[i], type = "tips")[[1]])
}
View(node_data)
nodes_5 <- node_data[(which(node_data[,2]>= sequences)),]
View(node_data)
#############################################
#            95% COVERAGE WGS               #
#############################################
# Make a dataframe ready to fill with info about number of gaps and N bases, and length of the alignment and sequence
seq_data <- data.frame(ID = alignment$nam, N = NA, "gap" = NA,
Length_before = nchar(alignment$seq[[1]]), Length_after = NA)
View(seq_data)
for (i in 1:length(alignment$seq)) {
seq_data$N[i] <- stringr::str_count(alignment$seq[[i]], pattern = 'n')
seq_data$gap[i] <- stringr::str_count(alignment$seq[[i]], pattern = '-')
seq_data$Length_after[i] <- (seq_data$Length_before[i] - seq_data$N[i] - seq_data$gap[i])
}
View(seq_data)
nodes_remove <- phangorn::Ancestors(tree,
(which(tree$tip.label
%in% (seq_data$ID[which(seq_data$Length_after < (seq_data$Length_before * 0.95))])
)),
'all')
View(nodes_remove)
View(seq_data)
15578*0.9
seq_data$Length_before * 0.95
for (i in 1:length(alignment$seq)) {
seq_data$N[i] <- stringr::str_count(alignment$seq[[i]], pattern = 'n')
seq_data$gap[i] <- stringr::str_count(alignment$seq[[i]], pattern = '-')
seq_data$Length_after[i] <- (seq_data$Length_before[i] - seq_data$N[i])
}
nodes_remove <- phangorn::Ancestors(tree,
(which(tree$tip.label
%in% (seq_data$ID[which(seq_data$Length_after < (seq_data$Length_before * 0.95))])
)),
'all')
removes <- nodes_remove[[1]]
which(seq_data$Length_after < (seq_data$Length_before * 0.95))
removes <- nodes_remove[[1]]
for (i in 2:(length(nodes_remove))) {
removes <- c(removes, nodes_remove[[i]])
}
remove_counts <- data.frame(table(removes))
# Make a table to count the number the removed sequences descended from each node (e.g. for the deeper nodes, all 10 are descended)
names(remove_counts) <-c('Node', 'freq')
# Change the names
remove_counts$Node <- as.integer(levels(remove_counts$Node))
# Need to change this, or it creates many levels and causes errors
new_remove <- remove_counts[which(remove_counts[,1] %in% nodes_5[,1]),]; new_remove
# Not all nodes are included in the nodes_5 data (some are already excluded)
# Get rid of the nodes not in the nodes_5 data
nodes_new<-nodes_5
for (i in new_remove$Node) {
nodes_new[which(nodes_new == i), 2] <-(nodes_5[which(nodes_5 == i), 2] - (new_remove[which(new_remove == i), 2]))
}
# Take away the number of removed tips from the previous total number of tips calculated for each node
nodes_5 <- nodes_new[(which(nodes_new[,2] >= sequences)),] # Redo this to remove any that now have less than 5, and write over the old nodes_5 so this is updated with the new tip numbers
#############################################
#         DIFFERENCE FROM ANCESTOR          #
#############################################
seq_data$Year <- NA # Add another column to the seq data ready to fill in dates
# Add collection year of each sequence to the table (Use latest, as exact collection not always filled in)
for (i in 1:length(alignment$seq)) {
seq_data$Year[i] <- metadata$year[which(metadata$ID == seq_data$ID[i])]
}
nodes_5$diff <- NA # Add a column in nodes_5 to count the number of nucleotide differences each cluster has from the old seq
nodes_reduced <- data.frame(Nodes = (nodes_5$Node - (1+length(tree$tip.label))))
for (i in 1:length(nodes_5$Node)) {
cm <- caper::clade.members(nodes_5$Node[i], tree, include.nodes = F, tip.labels = T)
seq_cm <- which(seq_data$ID %in% cm)
old <- which(row.names(ancestral_matrix) == paste("NODE_", (sprintf("%07d", nodes_reduced$Nodes[i])), sep=""))
tips <- which(row.names(ancestral_matrix) %in% cm)
x <- which(ancestral_matrix[old,] != ancestral_matrix[(tips[1]),])
for (j in tips[-c(1)]) {
x <- x[which(x %in% (which(ancestral_matrix[old,] != ancestral_matrix[j,])))]
print(x)
nodes_5$diff[i] <- length(x)
}
}
nodes_diff <- nodes_5[(which(nodes_5[,3]!=0)),] # Get rid of the ones with no differences straight away
#############################################
#         OVERLAPPING TIPS REMOVAL          #
#############################################
# Add a column to nodes_diff and for each node, count how many of the other nodes of interest are descended from it
nodes_diff$overlaps <- NA
for (i in 1:length(nodes_diff$Node)) {
nodes_diff$overlaps[i] <- length(which((phangorn::allDescendants(tree)[[(nodes_diff[i,1])]]) %in% nodes_diff[,1]))
}
# Create a data frame for lineage assignments. Add the tip labels, and a column ready to add the lineage they're assigned to
lineage_assignments <- data.frame(tip = tree$tip.label, cluster = NA)
# Order the nodes of interest by the number of times they overlap the other nodes of interest (descending)
nodes_diff <- nodes_diff[order(-nodes_diff$overlaps),]
# Add a column called cluster and label the clusters
nodes_diff$cluster <- c(1:(length(nodes_diff$Node)))
for (i in 1:(length(nodes_diff$Node))) {
lineage_assignments[which(lineage_assignments[,1] %in% caper::clade.members(nodes_diff[i,1], tree, include.nodes = F, tip.labels = T)), 2] <- nodes_diff[i,5]
}
summary <- data.frame(cluster = nodes_diff$cluster, count = NA)
for (i in 1:(length(summary$cluster))) {
summary$count[i] <- length(which(lineage_assignments$cluster == summary$cluster[i]))
}
nodes_diff <- nodes_diff[-c(which(nodes_diff$cluster %in% summary$cluster[(which(summary$count < 2))])),]
min <- min(summary$count)
while (min < 2){
nodes_diff <- nodes_diff[order(-nodes_diff$overlaps),]
nodes_diff$cluster <-c(1:(length(nodes_diff$Node)))
lineage_assignments$cluster <- NA
for (i in c(1:(length(nodes_diff$Node)))) {
lineage_assignments[which(lineage_assignments[,1] %in% caper::clade.members((nodes_diff[i,1]), tree, include.nodes = F, tip.labels = T)),2]<-nodes_diff[i,5]
}
summary <- data.frame(cluster = nodes_diff$cluster, count = NA)
for (i in 1:(length(summary$cluster))) {
summary$count[i] <- length(which(lineage_assignments$cluster == summary$cluster[i]))
}
min <- min(summary$count)
if (min == 2) {
print("done")
} else {
nodes_diff<-nodes_diff[-c(which(nodes_diff$cluster %in% summary$cluster[(which(summary$count < 2))])), ]
}
}
for(i in 1:length(seq_data$ID)){
seq_data$cluster[i]<-lineage_assignments$cluster[which(lineage_assignments$tip == seq_data$ID[i])]
}
sequence_data<-seq_data
node_data<-nodes_diff
sequence_data$previous <- NA
for (i in 1:length(sequence_data$ID)) {
sequence_data$previous[i]<-
metadata$assignment[which(metadata$ID == sequence_data$ID[i])]
}
previous_assignments<-data.frame(assignment = unique(sequence_data$previous), node = NA)
node_data$previous<-NA
for (i in 1:length(node_data$Node)) {
clades<-unique(sequence_data$previous[
which(sequence_data$ID %in% tree$tip.label[c(unlist(
phangorn::Descendants(tree, node_data$Node[i], type = "tips")))])])
node_data$previous[i]<-
paste(c(clades), collapse = ", ")
}
for (i in 1:length(previous_assignments$assignment)) {
previous_assignments$node[i]<-which(node_data$previous == previous_assignments$assignment[i])[1]
previous_assignments$assignment[i]<-previous_assignments$assignment[i]
}
possible_names<-data.frame(names = rep(previous_assignments$assignment, 26))
previous_assignments$assignment<-paste(previous_assignments$assignment, "_A1", sep = "")
for (i in 1:length(previous_assignments$assignment)) {
node_data$cluster[previous_assignments$node[i]]<-previous_assignments$assignment[i]
}
if ((length(which(previous_assignments$node == 1))) == 0) {
node_data$cluster[1]<-"A1"
}
node_data$test <- NA
problem_names<-data.frame(letters = c("A1", "B1", "C1", "D1", "E1", "F1", "G1", "H1", "I1", "J1", "K1", "L1", "M1", "N1",
"O1", "P1", "Q1", "R1", "S1", "T1", "U1", "V1", "W1", "X1", "Y1", "Z1"))
possible_names<-possible_names[order(possible_names$names),]
possible_names<-paste(possible_names, problem_names$letters, sep = "_")
for (i in 1:length(node_data$Node)) {
test<-which(node_data$Node %in% ips::descendants(tree, node_data$Node[i], type = "all", ignore.tip = T))
node_data$test[c(test)] <- paste(node_data$cluster[i], ".1", sep = "")
node_data$test<-stringr::str_replace(node_data$test, "A1\\..\\..\\..", "B1")
node_data$test<-stringr::str_replace(node_data$test, "B1\\..\\..\\..", "C1")
node_data$test<-stringr::str_replace(node_data$test, "C1\\..\\..\\..", "D1")
node_data$test<-stringr::str_replace(node_data$test, "D1\\..\\..\\..", "E1")
node_data$test<-stringr::str_replace(node_data$test, "E1\\..\\..\\..", "F1")
node_data$test<-stringr::str_replace(node_data$test, "F1\\..\\..\\..", "G1")
node_data$test<-stringr::str_replace(node_data$test, "G1\\..\\..\\..", "H1")
majors<-which(grepl("_", node_data$test))
node_data$cluster[c(majors)] <- node_data$test[c(majors)]
for (k in 1:length(possible_names)) {
if (length(which(node_data$cluster == possible_names[k]))>1) {
problems<-which(node_data$cluster == possible_names[k])
problems<-problems[-c(1)]
y=1
for (a in 1:length(problems)) {
letter<-which(problem_names$letters == (stringr::str_split(node_data$cluster[problems[a]], "_")[[1]][2]))
node_data$cluster[problems[a]]<-paste((stringr::str_split(node_data$cluster[problems[a]], "_")[[1]][1]), problem_names$letters[(letter+y)], sep = "_")
y = y+1
}
}
}
duplicates<-unique(node_data$cluster[duplicated(node_data$cluster)])
problems<-duplicates[which(stringr::str_count(duplicates, pattern = "\\.") == 0)]
duplicates<-duplicates[which(stringr::str_count(duplicates, pattern = "\\.") != 0)]
for (i in 1:length(duplicates)) {
test<-which(node_data$cluster == duplicates[i])
test<-test[-c(1)]
x<-1
for (j in 1:length(test)) {
name<-unlist(stringr::str_split(node_data$cluster[test[j]], "\\."))
name[length(name)]<-x+as.integer(name[length(name)])
x<-(x+1)
node_data$cluster[test[j]]<-paste(c(name), collapse='.' )
}
}
}
unclassified<-which(!grepl("_", node_data$cluster))
unclassified<-unclassified[c(-1)]
for (i in 1:length(node_data$Node)) {
test<-which(node_data$Node %in% ips::descendants(tree, node_data$Node[i], type = "all", ignore.tip = T))
node_data$test[c(test)] <- paste(node_data$cluster[i], ".1", sep = "")
node_data$test<-stringr::str_replace(node_data$test, "A1\\..\\..\\..", "B1")
node_data$test<-stringr::str_replace(node_data$test, "B1\\..\\..\\..", "C1")
node_data$test<-stringr::str_replace(node_data$test, "C1\\..\\..\\..", "D1")
node_data$test<-stringr::str_replace(node_data$test, "D1\\..\\..\\..", "E1")
node_data$test<-stringr::str_replace(node_data$test, "E1\\..\\..\\..", "F1")
node_data$test<-stringr::str_replace(node_data$test, "F1\\..\\..\\..", "G1")
node_data$test<-stringr::str_replace(node_data$test, "G1\\..\\..\\..", "H1")
node_data$cluster[unclassified]<-node_data$test[unclassified]
for (v in 1:length(problem_names$letters)) {
if (length(which(node_data$cluster == problem_names$letters[v]))>1) {
problems<-which(node_data$cluster == problem_names$letters[v])
problems<-problems[-c(1)]
y=1
for (f in 1:length(problems)) {
letter<-which(problem_names$letters == (node_data$cluster[problems[f]]))
node_data$cluster[problems[f]]<-problem_names$letters[(letter+y)]
y = y+1
}
}
}
duplicates<-unique(node_data$cluster[duplicated(node_data$cluster)])
problems<-duplicates[which(stringr::str_count(duplicates, pattern = "\\.") == 0)]
duplicates<-duplicates[which(stringr::str_count(duplicates, pattern = "\\.") != 0)]
for (i in 1:length(duplicates)) {
test<-which(node_data$cluster == duplicates[i])
test<-test[-c(1)]
x<-1
for (j in 1:length(test)) {
name<-unlist(stringr::str_split(node_data$cluster[test[j]], "\\."))
name[length(name)]<-x+as.integer(name[length(name)])
x<-(x+1)
node_data$cluster[test[j]]<-paste(c(name), collapse='.' )
}
}
}
node_data<-node_data[, -c((grep("test", names(node_data))), grep("previous", names(node_data)))]
for (i in 1:length(node_data$cluster)) {
sequence_data$cluster[which(sequence_data$cluster == i)] <- node_data$cluster[i]
}
sequence_data<-sequence_data[,-c(4)]
names(sequence_data)<-c("ID", "n_N", "n_gap", "length", "year", "lineage", "previous")
View(sequence_data)
View(sequence_data)
write.csv(sequence_data, file = (paste(args, "/Outputs/", args, "_sequence_data.csv", sep = "")), row.names=F)
View(node_data)
lineage_info<-MADDOG::lineage_info(sequence_data, metadata)
write.csv(node_data, file = (paste(args, "/Outputs/", args, "_node_data.csv", sep = "")), row.names=F)
for (i in 1:length(sequence_data$ID)) {
sequence_data$country[i] <- metadata$country[(which(metadata$ID == sequence_data$ID[i]))]
}
# Create a data frame ready to fill in information about each cluster
clusters <- sequence_data %>%
dplyr::group_by(lineage) %>%
dplyr::summarise()
library(dplyr)
# Create a data frame ready to fill in information about each cluster
clusters <- sequence_data %>%
dplyr::group_by(lineage) %>%
dplyr::summarise()
clusters$country <- NA
clusters$year_first <- NA
clusters$year_last <- NA
# Add another column listing the number of sequences assigned to each cluster
clusters$n_seqs<-(sequence_data %>%
dplyr::group_by(lineage)%>%
dplyr::summarise(n=dplyr::n()))$n
clusters<-clusters[-c(which(is.na(clusters$lineage))),]
# For each cluster, find and list the earliest collection year, the latest collection year and all the places
# that cluster has been found
for (i in 1:length(clusters$lineage)) {
clusters$year_first[i] <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()%>%
min()
clusters$year_last[i] <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()%>%
max()
clusters$country[i]<-paste((sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i] & country !="-") %>%
dplyr::group_by(country) %>%
dplyr::summarise()))
}
View(clusters)
View(metadata)
View(sequence_data)
View(seq_data)
View(sequence_data)
View(seq_data)
View(clusters)
View(sequence_data)
View(seq_data)
View(sequence_data)
View(seq_data)
View(sequence_data)
View(seq_data)
# For each cluster, find and list the earliest collection year, the latest collection year and all the places
# that cluster has been found
for (i in 1:length(clusters$lineage)) {
clusters$year_first[i] <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()%>%
min()
clusters$year_last[i] <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()%>%
max()
clusters$country[i]<-paste((sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i] & country !="-") %>%
dplyr::group_by(country) %>%
dplyr::summarise()))
}
View(clusters)
clusters$lineage[i]
filter(sequence_data$lineage == clusters$lineage[i])
dplyr::filter(sequence_data$lineage == clusters$lineage[i])
sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])
sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)
sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()
sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()%>%
min()
sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()%>%
min(year)
sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
min(dplyr::summarise())
test <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()%>%
min()
test <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()
View(test)
test <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()[1]
test[1,]
test[,1]
test <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()[,1]
min(test$year)
# For each cluster, find and list the earliest collection year, the latest collection year and all the places
# that cluster has been found
for (i in 1:length(clusters$lineage)) {
test <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::summarise()
clusters$year_first[i]<-min(test$year)
clusters$year_last[i] <- max(test$year)
clusters$country[i]<-paste((sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i] & country !="-") %>%
dplyr::group_by(country) %>%
dplyr::summarise()))
}
View(clusters)
# For each cluster, find and list the earliest collection year, the latest collection year and all the places
# that cluster has been found
for (i in 1:length(clusters$lineage)) {
test <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::filter(year != "-")
dplyr::summarise()
clusters$year_first[i]<-min(test$year)
clusters$year_last[i] <- max(test$year)
clusters$country[i]<-paste((sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i] & country !="-") %>%
dplyr::group_by(country) %>%
dplyr::summarise()))
}
# For each cluster, find and list the earliest collection year, the latest collection year and all the places
# that cluster has been found
for (i in 1:length(clusters$lineage)) {
test <- sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i])%>%
dplyr::group_by(year)%>%
dplyr::filter(year != "-")%>%
dplyr::summarise()
clusters$year_first[i]<-min(test$year)
clusters$year_last[i] <- max(test$year)
clusters$country[i]<-paste((sequence_data %>%
dplyr::filter(sequence_data$lineage == clusters$lineage[i] & country !="-") %>%
dplyr::group_by(country) %>%
dplyr::summarise()))
}
View(clusters)
write.csv(clusters, file = (paste(args, "/Outputs/", args, "_lineage_info.csv", sep = "")), row.names=F)
